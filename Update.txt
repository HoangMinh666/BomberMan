MAINUI.CPP
#include <iostream>
#include <SFML/Graphics.hpp>
#include "Until.h"
#include <iostream>
#include "Point2D.h"
#include "Map2D.h"
#include <conio.h> 
#include <time.h>
#include "Wall.h"
#include "Brick.h"
#include "BomberMan.h"
#include "Bomb.h"
#include "Portal.h"


#pragma comment (lib, "sfml-graphics-d.lib")
#pragma comment (lib, "sfml-audio-d.lib")
#pragma comment (lib, "sfml-network-d.lib")
#pragma comment (lib, "sfml-window-d.lib")
#pragma comment (lib, "sfml-system-d.lib")


using namespace std;
using namespace sf;
char ch;
int main() {
	//create Object
	
	Map2D map;
	Wall wall(map);  
	Brick brick(map);
	BomberMan player;
	Portal portal(brick);
	Bomb bomb;
	//Worm worm;
	//Snake snake;

	//create UI
	sf::RenderWindow window(sf::VideoMode(MAX_WIDTH*sizeCell , MAX_HEIGHT*sizeCell), "SFML example.");
	
	Texture t1, t2, t3, t4, t5;
	t1.loadFromFile("D:/iimei/images.png");
	t2.loadFromFile("D:/iimei/Bomberman.png");
	t3.loadFromFile("D:/iimei/wall2.png");
	t4.loadFromFile("D:/iimei/Brick.png");
	
	Sprite spriteBackground(t1);
	Sprite spriteBomberMan(t2);
	Sprite spriteBorder(t3);
	Sprite spriteBrick(t4);
	

	while (window.isOpen()) {
		Event e;
		while (window.pollEvent(e))
		{
			if (e.type == Event::Closed)
				window.close();
		}
		
		if (Keyboard::isKeyPressed(Keyboard::Left))	    ch = 75;
		if (Keyboard::isKeyPressed(Keyboard::Right))    ch = 77;
		if (Keyboard::isKeyPressed(Keyboard::Up))	    ch = 72;
		if (Keyboard::isKeyPressed(Keyboard::Down))     ch = 80;

		//Process
		//snake.Move();
		////ake.Catch(&worm);
		//if(snake.Catch(&worm))
		//{
		//	worm.Hurted();
		//	worm.Display();
		//	//Score;
		//}
		//if (snake.CheckIsDead()) {
		//	break;
		//}
	//	while (!brick.IsDestroyed() && player._liveLeft)
	//{
	//	if (_kbhit())
	//	{
	//		char ch = _getch();
		if (ch == 72 || ch == 80 || ch == 75 || ch == 77) player.Move(map, ch, bomb);
		else if (ch == ' ') player.SetBomb(bomb, map);
	//		else if (ch == 'p') _getch();
	//	}
	//	//player.Display();
	////	player.DisplayBomberManUI(spriteBomberMan, window);

	//	//player.GetPortal(map, bomb, portal);
	//	//if (!bomb._isExplosion)
	//	//	if (bomb.BombExplosion(map, portal, brick, player._bomberMan))
	//	//	{
	//	//		player.ResetBomberMan(bomb);
	//	//		GoToXY(17, MAX_HEIGHT); cout << player._liveLeft;
	//	//	}
	//player.DisplayBomberManUI(spriteBomberMan, window);
	//	}
		//update UI
		window.clear();
		map.DisplayMapUI(spriteBackground, spriteBorder, spriteBrick, window);
		player.DisplayBomberManUI(spriteBomberMan, window);
	//	snake.DisplaySnakeUI(spriteRed, window);
		window.display();
	}

	return 0;
}




UPDATE MAP2D.CPP
void Map2D::DisplayMapUI(sf::Sprite &spBackground, sf::Sprite &spBorder, sf::Sprite &spBrick, sf::RenderWindow &window) {
	for (int y = 0; y < MAX_HEIGHT; y++)
		for (int x = 0; x < MAX_WIDTH; x++)
		{
			if (_map[y][x].GetC() == '#'||_map[y][x].GetC() == 'W')
			{
				spBorder.setPosition(x*sizeCell, y*sizeCell);
				window.draw(spBorder);
			}
			
			else if (_map[y][x].GetC() == 'B')
			{
				spBrick.setPosition(x*sizeCell, y*sizeCell);
				window.draw(spBrick);
			}
			else {
				spBackground.setPosition(x*sizeCell, y*sizeCell);
				window.draw(spBackground);
			}
		}
}

UPDATE BOMBERMAN.CPP
void BomberMan :: DisplayBomberManUI(sf::Sprite &spBomberMan, sf::RenderWindow &window)
{
		if ( _bomberMan.GetC() == 'X') 
			{
				spBomberMan.setPosition(_bomberMan.GetX()*sizeCell, _bomberMan.GetY()*sizeCell);
				window.draw(spBomberMan);
			}
}


MONSTER.H
#pragma once 
#include "Map2D.h"
#include "Point2D.h"
#include "Until.h"
#include "Bomb.h"
class Monster
{
public:
	Monster(Map2D map);
	~Monster();

	int		_start;

	void	Move(Map2D& map, Bomb bomb);
	void	TurnUp(Map2D map, Point2D &monster, int &direction);
	void	TurnDown(Map2D map, Point2D &monster, int &direction);
	void	TurnLeft(Map2D map, Point2D &monster, int &direction);
	void	TurnRight(Map2D map, Point2D &monster, int &direction);
	void	Display();
	bool	CheckPosition(int x, int y, Map2D map);
private:
	Point2D _monster[MAX_MONSTER];
	int		_direction[MAX_MONSTER];
	bool	_checkDead[MAX_MONSTER];
};


MONSTER.CPP
#include <iostream>
#include "Point2D.h"
#include "Monster.h"
#include "Until.h"
using namespace std;

Monster :: Monster(Map2D map)
{
	int x, y; bool check;
	for (int i = 0; i < MAX_MONSTER; ++i)
	{
		while (true)
		{
			x = GetRandomNumber(MAX_WIDTH - 2) + 1;
			y = GetRandomNumber(MAX_HEIGHT - 2) + 1;
			if (x < 3 && y < 3) continue;
			if (map._map[y][x].GetC() == ' ')
			{
				_monster[i] = Point2D(x, y, '$');
				break;
			}
		}
		_checkDead[i] = false;
		_direction[i] = 0;
	}
}

Monster :: ~Monster()
{
}

void Monster :: Display()
{
	for(int i = 0; i < MAX_MONSTER; ++i) 
		if(!_checkDead[i]) _monster[i].Display();
}

void Monster::TurnUp(Map2D map, Point2D &monster, int &direction)
{
	if (CheckPosition(monster.GetX(), monster.GetY() - 1, map)) monster.MoveUp();
	else direction = rand() % 4;
}

void Monster::TurnDown(Map2D map, Point2D &monster, int &direction)
{
	if (CheckPosition(monster.GetX(), monster.GetY() + 1, map)) monster.MoveDown();
	else direction = rand() % 4;
}

void Monster::TurnLeft(Map2D map, Point2D &monster, int &direction)
{
	if (CheckPosition(monster.GetX() - 1, monster.GetY(), map)) monster.MoveLeft();
	else direction = rand() % 4;
}

void Monster::TurnRight(Map2D map, Point2D &monster, int &direction)
{
	if (CheckPosition(monster.GetX() + 1, monster.GetY(), map)) monster.MoveRight();
	else direction = rand() % 4;
}

void Monster::Move(Map2D& map, Bomb bomb)
{
	if (_start > 0 && ((clock() - _start) / (double)CLOCKS_PER_SEC) < 0.03)
		return;
	_start = 0;
	for(int i = 0; i < MAX_MONSTER; ++i)
	{
		int x = _monster[i].GetX(), y = _monster[i].GetY();
		Sleep(200);
		_monster[i].Clear();
		if (_direction[i] == 0) TurnUp(map, _monster[i], _direction[i]);
		else if (_direction[i] == 1) TurnDown(map, _monster[i], _direction[i]);
		else if (_direction[i] == 2) TurnLeft(map, _monster[i], _direction[i]);
		else if (_direction[i] == 3) TurnRight(map, _monster[i], _direction[i]);	
	}
}

bool Monster::CheckPosition(int x, int y, Map2D map)
{
	if (map._map[y][x].GetC() == ' ') return true;
	return false;
}
